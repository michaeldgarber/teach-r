---
title: "Monte Carlo simulations and boots with the purrr::map_dfr()"
author: "Michael D. Garber, PhD MPH"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_float: true
    number_sections: true
bibliography: references.bib
csl: american-medical-association.csl
link-citations: true
---

![source: <https://commons.wikimedia.org/wiki/File:Wiki79.jpg>](images/chevy-monte-carlo-pic.jpg){width="500"}

# Learning objectives

-   Provide a working definition of Monte Carlo simulations and bootstrapping.

-   Perform each using R.

# Motivation

## Sources of uncertainty from multiple sources

Almost any epidemiological or statistical analysis has uncertainty. Uncertainty may arise within the dataset available for analysis (the sample) or, if we aim to infer characteristics of a larger population from the sample, from sampling. For example, suppose we want to estimate the prevalence of Covid-19 in a county. To do so, we randomly sample 1,000 people from that county and test them using at-home antigen tests. Home tests have good specificity but fairly poor sensitivity,[@chu2022] meaning some of the negative results were probably truly positive (false negative). And because the poor sensitivity is a property of the test, not the sampling, this error is expected to occur regardless of the sample size. In addition to this systematic error in measurement, uncertainty arises from the sampling because we don't know if the Covid prevalence among the 1,000 people we tested represents that of the county. By chance, we could have tested a particularly healthy or sick sample.

In our final estimate of prevalence, how would we go about summarizing its uncertainty, considering both the expected error in measurement and random error from sampling? Statistics of course has fundamental methods for estimating uncertainty from multiple sources, but many traditional methods for estimating variance involve complex math.[@distribu2022a] To simplify the math, analysts often make assumptions that may not hold, for example that random variables considered in the analysis are independent from one another. In this particular example, the two sources of uncertainty (test accuracy and sampling) may be independent from one another, but that independence often does not hold.

## When independence between sources of uncertainty does not hold

For example, in my dissertation, I aimed to estimate the total amount of bicycling on every road in Atlanta. I had two sources of information, both of which had uncertainty. The first was a sample of bicycling on every roadway obtained from a smartphone app, inducing sampling variability and probably selection bias.[@garber2022] The second was a set of about 15 bicycle counters located throughout the city, assumed to accurately measure all bicycling in that location. I used these counters to estimate the proportion of bicyclists captured by the app. In this analysis, bike traffic in the smartphone-generated sample was correlated with the proportion captured in the app over the counter locations, meaning that estimating the variance of their product should consider this lack of independence. Accurately estimating the variance arising from both of these inter-related sources by appropriately considering their covariance using traditional pen-and-paper statistical methods, and propagating that combined uncertainty through other steps in the analysis which may themselves have uncertainty, would be difficult.

# Estimating variability via repeated (re)sampling of random variations

Fortunately, we can estimate uncertainty using computer simulations which largely obviates the need to do complex math. Two broad ways to estimate uncertainty using computer-based simulation techniques are **Monte Carlo simulations** and **bootstrapping**. In addition to easing the math, these simulation methods can help the analyst see how and when something varies in the analysis, which facilitates clarity and understanding.

## Monte Carlo simulations

> "Monte Carlo simulation is a method of analysis based on artificially recreating a chance process (usually with a computer), running it many times, and directly observing the results."[@barreto]

An important aspect of a traditional Monte Carlo simulation is that the distribution (i.e., its mean and variance) of each individual source of uncertainty is specified by the analyst. It is not estimated from the data. Monte Carlo simulations are useful to propagate multiple sources of variation throughout an analysis pipeline to assess the impact of all sources of uncertainty on the final result. And, as noted, they're especially helpful compared with traditional (non-computer-based) statistical methods when those sources of variation are correlated with one another.

## Bootstrapping

Monte Carlo simulation in its typical implementation cannot, however, directly estimate the sampling distribution. But bootstrapping can.

> "In statistics..., bootstrapping has come to mean to resampling [with replacement] repeatedly and randomly from an original, initial sample using each bootstrapped sample to compute a statistic. The resulting empirical distribution of the statistic is then examined and interpreted as an approximation to the true sampling distribution."[@barreto2005]

The bootstrap was introduced by Bradley Efron in the late 1970s.[@bootstra2022c; @efron1979] There are many forms of bootstrapping, including ways to bootstrap residuals from regression models.[@efron2016] In its most basic form, to bootstrap means to re-sample observations from the sample, compute summary statistics from each re-sampled sample, and use the distribution of those summary statistics to infer the sampling distribution.

The bootstrap is similar conceptually to Monte Carlo techniques because it involves randomly changing the data over repeated iterations and summarizing results of those iterations. The key difference is that the bootstrap estimates a distribution using data we have, and, under the Monte Carlo technique described, the distribution of each variable is specified by the analyst.

# Example code for each method using `purrr::map_dfr()`

## Monte Carlo simulation

Suppose we have a state with 100 counties. We simulate one single dataset, specifying that the mean county population is 1,000 and the probability of a binary demographic variable (`dem`; say urban versus rural) is 0.5. The prevalence (`prev`) depends in part on `pop` and `dem`, and the number of cases in the county is estimated from `pop` and `prev`.

```{r, message=FALSE, warning=FALSE}
library(tidyverse)
library(truncnorm)
set.seed(11)#set the seed so this dataset is always the same.
monte_carlo_sim_frozen = 1:100 %>% 
  as_tibble() %>% 
  rename(county_id = value) %>% 
  mutate(
    state = 1,
    pop = rpois(n=n(), lambda=10000), #poisson dist. mean = var=1000
    dem = rbinom(n=n(), size=1, prob =.5), #binomial dist.
    prev = rtruncnorm( #truncated normal so prevalence is bounded by 0,1
      n=n(), 
      a=0, 
      b=1,
      mean=0.05+(pop/50000)+(dem/10),
      sd=0.05 +(pop/200000)+(dem/40)),
    n_cases = as.integer(pop*prev),
  )

monte_carlo_sim_frozen
```

Note that population `pop` and `prev` are correlated. That is, they're not independent from one another, so when estimating variability of their product, `n_cases`, that correlation should be considered.

```{r}
cor(monte_carlo_sim_frozen$pop,
     monte_carlo_sim_frozen$prev)
```

What is the mean and standard deviation number of cases per county? Note we have not run any replications yet. This is just *one iteration* of the theoretical dataset of counties in a state.

```{r}
monte_carlo_sim_frozen %>% 
  group_by(state) %>% 
  summarise(
    n_cases_mean = mean(n_cases),
    n_cases_sd = sd(n_cases)) %>% 
  ungroup()
```

What is the distribution of the number of cases between counties in the state for this one replication?

```{r}
monte_carlo_sim_frozen %>% 
  ggplot(aes(n_cases))+
  geom_histogram()
```

### Define a function for replications

Now let's randomly vary values of the variables over several replications. In this code, we will create a function that will create new variables whose values will randomly change. Functions are described in the [functions chapter](https://r4ds.had.co.nz/functions.html#functions) of R 4 Data Science. At the end of this module, I have another example of how to use a function in a dplyr pipe.

Create a function for the creation of this dataset, run it 500 times, and find the mean of the means over those 500 iterations. Our function's one argument is `rep_id_val`. Its value is used in the `mutate()` step to create a variable called `rep_id`.

```{r}
monte_carlo_sim_fun = function(rep_id_val){
  monte_carlo_sim_df = 1:100 %>% 
    as_tibble() %>% 
    rename(county_id = value) %>% 
    mutate(
      state = 1,
      pop = rpois(n=n(), lambda=10000),  
      dem = rbinom(n=n(), size=1, prob =.5),
      prev = rtruncnorm(
        n=n(), 
        a=0, 
        b=1,
        mean=0.05+(pop/50000)+(dem/10),
        sd=0.05 +(pop/200000)+(dem/40)),
    n_cases = as.integer(pop*prev),
    rep_id = rep_id_val  #add replication ID
  )
}
```

To see how the function works, run one iteration of it:

```{r}
monte_carlo_sim_once = monte_carlo_sim_fun(rep_id_val = 5)
monte_carlo_sim_once
```

Now let's run the function lots of times. Define the number of replications. Here, we are creating an integer vector ranging from 1 to 500.

```{r}
rep_id_val_list = 1:500
class(rep_id_val_list)
```

### Run the replications

Simulate 500 versions of this state. In each replication, the values for the variables `pop`, `dem`, `prev`, and `n_cases` randomly vary according to their specified distribution. We use [`map_dfr()`](https://purrr.tidyverse.org/reference/map.html) from the [purrr](https://purrr.tidyverse.org/) package to run the simulation and then stack the results from each iteration on top of one another, akin to `dplyr::bind_rows()`.

Take note of the unusual structure of this code. The function we created above, `monte_carlo_sim_fun` is inside of `map_dfr()`, and the list of replication ids, `rep_id_val_list,` is the object that begins the pipe sequence.

```{r}
library(purrr) #make sure it's attached
set.seed(NULL) #allow it to vary differently each time.
monte_carlo_sim_lots  = rep_id_val_list %>% 
  map_dfr(monte_carlo_sim_fun) 
```

Take a look at the output.

```{r}
monte_carlo_sim_lots
```

How many rows?

```{r}
nrow(monte_carlo_sim_lots)
```

How many distinct values of `rep_id`?

```{r}
n_distinct(monte_carlo_sim_lots$rep_id)
```

### Summarize results

What's the distribution of `n_cases_mean` over Monte Carlo replications? This is not the variability of the number of cases within the state between counties but rather the variability of the mean number of county-level cases between replications.

```{r, message=FALSE, warning=FALSE}
monte_carlo_sim_lots %>% 
  group_by(rep_id,state) %>% 
  summarise(
    n_cases_mean = mean(n_cases),
    n_cases_sd = sd(n_cases)) %>% 
  ggplot(aes(n_cases_mean))+
  geom_histogram()
```

What is the 2.5th, 50th (median), and 97.5th percentile of the mean number of cases between replications? This could be used to report a confidence interval around that estimated mean.

```{r, message=FALSE, warning=FALSE}
monte_carlo_sim_lots_summary = monte_carlo_sim_lots %>% 
  group_by(rep_id,state) %>% #group by both rep id and state
  summarise(
    n_cases_mean = mean(n_cases),
    n_cases_sd = sd(n_cases)) %>% 
  group_by(state) %>% #now collapse over rep id
  summarise(
    n_cases_mean_ll = quantile(n_cases_mean, probs = 0.025, na.rm=TRUE),
    n_cases_mean_med = quantile(n_cases_mean, probs = 0.5, na.rm=TRUE),
    n_cases_mean_ul = quantile(n_cases_mean, probs = 0.975, na.rm=TRUE)
    ) %>% 
  ungroup() %>% 
  mutate(simulation_type = "monte-carlo")

monte_carlo_sim_lots_summary
```

## Bootstrap

Now let's bootstrap `monte_carlo_sim_frozen`, again supposing that even though it was generated randomly, it is now viewed as a single frozen sample - the one we drew and have access to. We can estimate the sampling distribution by re-sampling it **with replacement** with sampling probability of 1, meaning all rows will be re-sampled. Because we are sampling *with replacement*, in a given sample, some counties will repeat, and some will not appear at all.

Here's one sample:

```{r}
monte_carlo_sim_one_boot = monte_carlo_sim_frozen %>% 
  slice_sample(prop=1,replace=TRUE)
```

Take a look:

```{r}
monte_carlo_sim_one_boot
```

As expected, we have the same number of rows, but fewer unique values for `county_id.` Some are repeating.

```{r}
nrow(monte_carlo_sim_one_boot)
n_distinct(monte_carlo_sim_one_boot$county_id)
```

Repeat this bootstrap procedure 500 times by first writing a function and then iterating replications through that function using `purrr::map_dfr()`

### Define a function for replications

```{r}
boot_fun = function(rep_id_val){
  monte_carlo_sim_boot = monte_carlo_sim_frozen %>% 
    slice_sample(prop=1,replace=TRUE) %>% 
    mutate(rep_id = rep_id_val) #to keep track of reps
}
```

### Run the replications

Simulate 500 versions of this re-sampling. We again use `map_dfr()` from the purrr package to run the function and then stack the results on top of one another. Again take note of the unusual structure of this code. The function, `boot_fun`, is inside of `map_dfr()`, and the vector of replication ids, `rep_id_val_list,` begins the pipe sequence.

```{r}
boot_lots  = rep_id_val_list %>% 
  map_dfr(boot_fun) 
```

### Summarize results

```{r}
boot_lots
```

What's the distribution of `n_cases_mean` over bootstrap replications?

```{r message=FALSE, warning=FALSE}
boot_lots %>% 
  group_by(rep_id,state) %>% 
  summarise(
    n_cases_mean = mean(n_cases),
    n_cases_sd = sd(n_cases)) %>% 
  ggplot(aes( n_cases_mean))+
  geom_histogram()
```

We can use the empirical distribution of re-sampled results to estimate a confidence interval for the sampling distribution. This is a confidence interval for the estimated mean number of cases in the state:

```{r message=FALSE, warning=FALSE}
boot_lots_summary = boot_lots %>% 
  group_by(rep_id,state) %>% #group by both rep id and state
  summarise(
    n_cases_mean = mean(n_cases),
    n_cases_sd = sd(n_cases)) %>% 
  group_by(state) %>% #now collapse over rep id
  summarise(
    n_cases_mean_ll = quantile(n_cases_mean, probs = 0.025, na.rm=TRUE),
    n_cases_mean_med = quantile(n_cases_mean, probs = 0.5, na.rm=TRUE),
    n_cases_mean_ul = quantile(n_cases_mean, probs = 0.975, na.rm=TRUE)
    ) %>% 
  ungroup() %>% 
  mutate(simulation_type = "bootstrap")

boot_lots_summary
```

How does this estimate of the sampling distribution of `n_cases_mean` align with the truth? We happen to know the truth here. It's the distribution of `n_cases_mean` between the Monte Carlo simulations, defined above.

```{r}
monte_carlo_sim_lots_summary %>% 
  bind_rows(boot_lots_summary)
```

# Summary of Monte Carlo simulations and bootstrapping

Advantages of these computation-based simulation methods

-   Makes explicit where the variation is coming from and aids in intuition.

-   Easily accommodates correlation between variables and avoids difficult math.

Comparison between the two:

-   Difference: Is variability specified by the user or is it estimated from the sample?

-   In common: Both use repeated sampling to estimate uncertainty. Monte Carlo simulations may sample from a specified distribution to generate values for a variable, and bootstrapping samples the rows of the data at hand.

Broad steps for each:

1.  Define a function that contains steps of the analysis with variability.
2.  Run that function lots of times using `purrr::map_dfr()`
3.  Summarize the distribution of the results. Conventionally, to report percentile-based confidence intervals,[@efron2016a] take the median, 2.5th, and 97.5th percentiles.

# More on functions

In addition to their use for simulations as above, functions can also be used simply to reduce repetition in code. Sometimes you end up writing the same or similar code many times and apply that code to several datasets. For example, above, we wrote an almost identical sequence of dplyr functions to define both `monte_carlo_sim_frozen` and the function, `monte_carlo_sim_fun()`.

Here is an example sequence of dplyr steps combined into one function.

```{r}
do_some_dplyr_stuff = function(df){ 
  df %>%
  mutate(
    example_var_x=rnorm(n=n(), mean=0, sd=1),
    example_var_y=4,
    example_var_z = rbinom(n=n(), size=1, prob=.2)
  ) %>% 
  dplyr::select(state, county_id, starts_with("example"))
}  
```

The argument of the function here is a dataframe or tibble arbitrary called `df` . When we run this function in a piped chain, that df will be taken as the implied object, and the function can be run as if it were any other dplyr function.

Let's apply that function to one county from our `monte_carlo_sim_frozen` dataset.

```{r}
function_result_one_county = monte_carlo_sim_frozen %>% 
  filter(county_id==2) %>% 
  do_some_dplyr_stuff()

function_result_one_county
```

# **References**
